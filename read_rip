#!/usr/bin/python
#
# Copyright 2014 Fastly, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# read_rip consumes a trace file generated by a librip consumer and
# outputs thread status.
 
import sys, re, os, getopt, subprocess, bisect, struct
import zlib, gzip, cStringIO

USAGE = """\
read_rip [-e <path-to-executable>] [-r <path-to-librip-output>] [-t] [-v]
"""

NM_P_RE = re.compile(r'^([^ ]+) [^ ] ([0-9a-f]+) ([0-9a-f]+)', re.I)


def usage():
  print USAGE
  sys.exit(0)


def main():
  (opt_list, args) = getopt.gnu_getopt(sys.argv[1:], 'e:hr:tv', ['help'])
  if args :
    raise getopt.GetoptError('unexpected non-option argument(s): %r' % (args,))

  by_tid = False
  exe_filename = None
  ring_filename = None
  verbose_mode = False
  for (opt, val) in opt_list :
    if opt == '--help' or opt == '-h':
      usage()
    elif opt == '-e' :
      if exe_filename is not None :
        raise getopt.GetoptError('duplicate option -e')
      exe_filename = val
    elif opt == '-r' :
      if ring_filename is not None :
        raise getopt.GetoptError('duplicate option -r')
      ring_filename = val
    elif opt == '-t' :
      by_tid = True
    elif opt == '-v' :
      verbose_mode = True

  if exe_filename is None :
    raise getopt.GetoptError('Executable must be specified')

  if ring_filename is None :
    ring_filename = 'rip_ring'

  doit(exe_filename, ring_filename, verbose_mode, by_tid)


class SymbolTable(object):
  def __init__(self, exe_filename):
    self.symbols = []
    for line in subprocess.Popen(['nm', '-P', exe_filename],
        stdout=subprocess.PIPE).communicate()[0].split('\n') :
      m = NM_P_RE.match(line)
      if m :
        (name, addr, size) = m.groups()
        addr = int(addr, 16)
        size = int(size, 16)
        self.symbols.append((name, addr, size))
    self.symbols.sort(key=lambda (name, addr, size) : addr)
    self.addrs = [x[1] for x in self.symbols]

  def lookup(self, addr):
    i = bisect.bisect_right(self.addrs, addr)
    if i == 0 : # lower than the first entry
      return None
    (sym_name, sym_addr, sym_size) = self.symbols[i-1]
    offset = addr - sym_addr
    if offset < sym_size :
      return (sym_name, offset)
    else:
      return None


def addrs2locations(addrs, exe_filename):
  addrs_str = '\n'.join(map(hex, addrs))
  locations_str = subprocess.Popen(['addr2line', '-se', exe_filename],
      stdin=subprocess.PIPE, stdout=subprocess.PIPE).communicate(addrs_str)[0]
  locations = locations_str.rstrip().split('\n')
  assert len(addrs) == len(locations), repr(locations_str)

  for (i, location) in enumerate(locations[:]) :
    if location == '??:0' :
      locations[i] = hex(addrs[i])

  return locations


def read_ring(ring_filename, by_tid):
  addr_tid = []
  f = open(ring_filename, 'rb')
  d = f.read(64+256)

  if d.startswith('\x1f\x8b\x08') :  # gzip
    f.seek(0)
    f = gzip.GzipFile(fileobj=f, mode='rb')
    d = f.read(64+256)
  elif d.startswith('\x78\x9c') :  # old ripring's deflateInit defaults
    f = cStringIO.StringIO(zlib.decompress(d + f.read()))
    d = f.read(64+256)

  tid = 0
  while d != '' :
    assert len(d) == 64+256
    start = 0
    ctr = 0
    name = struct.unpack('64s', d[:64])[0].rstrip('\0')
    ctr_addr_list = struct.unpack('<32Q', d[64:])

    # The top 8 bits contain the slot counter, the remaining 24 bits contain
    # the address.  We should sign-extend the 24-bit address, but it does not
    # matter because we do not have instrumentation (or symbols) in anything
    # that is mapped into the higher half of the address space.
    #
    # Split the two out into a tuple: (ctr, addr).  Drop empty entries.
    # For an unused thread slot ctr_addr_list will end up empty.

    ctr_addr_list = [((entry & (0xff << 56)) >> 56, entry & 0x00ffffffffffffff)
                     for entry in ctr_addr_list
                     if entry != 0]

    if ctr_addr_list :
      # ctr_addr_list is a ring buffer.  The counter wraps around.  Find the
      # discontinuity in numbering modulo 256.  The entry after it is the
      # oldest entry.  Rotate the list to move that entry to the front.
      # The list will be thus in chronological order.  Example:
      # Before:   253 254 255 0 1 2 3 .. 24 249 250 251 252
      # After:    249 250 251 252 253 254 255 0 1 2 3 .. 24

      disco = None
      for i in range(len(ctr_addr_list)-1) :
        if ctr_addr_list[i+1][0] != (ctr_addr_list[i][0] + 1) & 0xff :
          disco = i+1
          break
      if disco is not None :
        ctr_addr_list = ctr_addr_list[disco:] + ctr_addr_list[:disco]

      if by_tid :
        for (ctr, addr) in ctr_addr_list:
          addr_tid.append((addr, tid, name, ctr))
      else:
        # The latest (most recent) entry is at the end after the rotation above.
        (ctr, addr) = ctr_addr_list[-1]
        addr_tid.append((addr, tid, name, ctr))

    d = f.read(64+256)
    tid += 1
  return addr_tid


def doit(exe_filename, ring_filename, verbose_mode, by_tid):
  st = SymbolTable(exe_filename)

  addrs = set()
  func_to_addr_and_tid_list = {}
  tid_to_addrs = {}
  tid_to_name = {}

  for (addr, tid, name, ctr) in read_ring(ring_filename, by_tid) :
    if not tid in tid_to_name:
      tid_to_name[tid] = name

    addrs.add(addr)
    if by_tid:
      if tid in tid_to_addrs:
        tid_to_addrs[tid].append((ctr, addr))
      else:
        tid_to_addrs[tid] = [(ctr, addr)]
    else:
      r = st.lookup(addr)
      if r is not None :
        func = r[0]
      else:
        func = 'UNKNOWN'

      if func in func_to_addr_and_tid_list :
        func_to_addr_and_tid_list[func].append((addr, tid))
      else:
        func_to_addr_and_tid_list[func] = [(addr, tid)]

  location2addrs = {}
  addr2location = {}
  addrs_list = list(addrs)
  for (i, location) in enumerate(addrs2locations(addrs_list, exe_filename)) :
    addr = addrs_list[i]
    addr2location[addr] = location
    if location in location2addrs :
      location2addrs[location].add(addr)
    else:
      location2addrs[location] = set([addr])

  if by_tid:
    for key in sorted(tid_to_addrs):
      locations = []

      for (ctr, addr) in tid_to_addrs[key] :
        location = addr2location[addr]
        if verbose_mode or len(location2addrs[location]) > 1 :
          locations.append('{%d}%s<%#x>' % (ctr, location, addr))
        else:
          locations.append('{%d}%s' % (ctr, location))

      if len(locations) == 1:
        continue
      else:
        print "%s[%d]: %s\n" % (tid_to_name[key], key, ', '.join(locations))

  else:
    for (func, addr_tid_list) in sorted(func_to_addr_and_tid_list.items(),
        key=lambda (func, addr_tid_list): -len(addr_tid_list)) :

      addr2tids = {}
      for (addr, tid) in addr_tid_list :
        if addr in addr2tids :
          addr2tids[addr].append(tid)
        else:
          addr2tids[addr] = [tid]

      addr2tids_str_items = []
      for addr in sorted(addr2tids.keys()) :

        location = addr2location[addr]
        if verbose_mode or len(location2addrs[location]) > 1 :
          location_str = '%s<%#x>' % (location, addr)
        else:
          location_str = location

        tids = addr2tids[addr]
        if verbose_mode :
          tids_str = '[%s]' % (', '.join(map(str,sorted(tids))),)
        else:
          tids_str = '(%d)' % (len(tids),)

        addr2tids_str_items.append(location_str+' '+tids_str)

      addr2tids_str = '; '.join(addr2tids_str_items)

      print '%s : %d thread%s, %d location%s: %s' % (
          func,
          len(addr_tid_list), ['','s'][len(addr_tid_list) != 1],
          len(addr2tids), ['','s'][len(addr2tids) != 1],
          addr2tids_str)


if __name__ == '__main__' :
  main()

# vim:set et ts=2 sw=2 sts=2:
